#!/usr/bin/python3
from baseGate import *

#split a gate to the elements in the Dic "allowGate"
class SplitGate:
	def __init__(self):
		self.allowSet = []
		for key in allowGate:
			if key == 'M':
				continue
			self.allowSet.append(key)

	#get the info about the function name and the line number
	def get_curl_info(self):
		try:
			raise Exception
		except:
			f = sys.exc_info()[2].tb_frame.f_back
		return [f.f_code.co_name, f.f_lineno]

	#convert the c0 to c1 by addind a X gate on the control-qubit
	#or restore the state of the control-qubit
	def __convert0to1(self,cql:list,vl:list):
		QASM = ""
		for i in range(0,len(cql)):
			if len(vl) == 1:
				j = 0
			else:
				j = i
			if vl[j] == 0:
				QASM += "X q" + str(cql[i].ids) + ";"
		#then the circuit is equal to c1-c1-c1-c1...-U
		return QASM

	#C-U means that this is a controlled-gate with only one control qubit
	#return value is the QASM code
	def CU(self,gateName:str,cq:Qubit,tq:Qubit,vl:list):
		QASM = ""
		QASM += self.__convert0to1([cq],vl)
		#all the control-gate can be split into CNOT and single-gate
		
		QASM += self.__convert0to1([cq],vl)
		return QASM

	#MC-U means that this is a controlled-gate with more than one control qubit
	#return value is the QASM code of this MCU
	def MCU(self,gateName:str,cql:list,tq:Qubit,vl:list):
		if gateName == "c1-c1-X":
			return self.Toffoli(cql[0],cql[1],tq)
		QASM = ""
		QASM += self.__convert0to1(cql,vl)
		#the multi-controlled qubit gate "c1-c1-c1-c1...-X" can be split to a series of Toffoli gates
		#then c1-c1-c1-c1...-U is same with this case

		QASM += self.__convert0to1(cql,vl)		
		return QASM

	#special-case, this is an important element in constructing MCU
	#the index of the control qubit and the target qubit is from 0 to n-1
	def Toffoli(self):
		#cq-0 stands for the cql[0]
		#tq-1 stands for the tql[1]
		QASM = "H tq-0;CNOT cq-1,tq-0;Td tq-0;CNOT cq-0,tq-0;T tq-0;CNOT cq-1,tq-0;Td tq-0;CNOT cq-0,tq-0;Td cq-1;T tq-0;CNOT cq-0,cq-1;H tq-0;Td cq-1;CNOT cq-0,cq-1;T cq-0;S cq-1"
		return QASM

	#record the entire gate in circuit.qubitExecuteList
	def __recordEG(self,gateName:str,cql:list,tql:list):
		resQL = cql.copy()
		for tq in tql:
			resQL.append(tq)
		cG = [[0] * (2**len(resQL))] * (2**len(resQL))
		#append the multi-controlled gate to Dict "allowGate", which is defined in baseGate.py
		allowGate[gateName] = len(resQL)
		#record the entire gate in circuit.qubitExecuteList
		#init the Gate instance
		gate = Gate(resQL,cG,gateName)
		c = gate.recordmultiExecution()

	#'er' is the QASM code generated by the other methods in this class
	#note that all the Single-Gate and Double-Gate in this function shouldn't be stored in circuit.qubitExecuteList	
	def execute(self,er,cqL:list,tqL:list,gateName:str):
		self.__recordEG(gateName,cqL,tqL)
		#execute the component gate
		erL = er.split(";")
		for item in erL:
			tmpStr = item.split(" ")
			gate = tmpStr[0]
			exeStr = gate + "("
			q = tmpStr[1].split(",")
			for i in range(0,len(q)):
				qType = q[i].split("-")[0]
				index = q[i].split("-")[1]
				if qType == "cq":
					exeStr += "cqL[" + index + "]"
				elif qType == "tq":
					exeStr += "tqL[" + index + "]"
				else:
					try:
						raise ValueError
					except ValueError:
						info = self.get_curl_info()
						writeErrorMsg("Qubit List: "+qtype+" isn't defined in Class SplitGate!",info[0],info[1])
				if i != len(q)-1:
					exeStr += ","
			exeStr += ",False)"
			exec(exeStr)
		resQL = cqL.copy()
		for tq in tqL:
			resQL.append(tq)
		return resQL

def X(q:Qubit,record = True):
	X = [[0,1],[1,0]]
	gate = Gate([q],X,"X")
	return gate.singleOperator(record)

def Y(q:Qubit,record = True):
	Y = [[0,-1j],[1j,0]]
	gate = Gate([q],Y,"Y")
	return gate.singleOperator(record)

def Z(q:Qubit,record = True):
	Z = [[1,0],[0,-1]]
	gate = Gate([q],Z,"Z")
	return gate.singleOperator(record)

def I(q:Qubit,record = True):
	I = [[1,0],[0,1]]
	gate = Gate([q],I,"I")
	return gate.singleOperator(record)


def H(q:Qubit,record = True):
	H = [[1/math.sqrt(2),1/math.sqrt(2)],[1/math.sqrt(2),-1/math.sqrt(2)]]
	gate = Gate([q],H,"H")
	return gate.singleOperator(record)

def S(q:Qubit,record = True):
	S = [[1,0],[0,1j]]
	gate = Gate([q],S,"S")
	return gate.singleOperator(record)

def Sd(q:Qubit,record = True):
	Sd = [[1,0],[0,-1j]]
	gate = Gate([q],Sd,"Sd")
	return gate.singleOperator(record)


def T(q:Qubit,record = True):
	T = [[1,0],[0,(1+1j)/math.sqrt(2)]]
	gate = Gate([q],T,"T")
	return gate.singleOperator(record)

def Td(q:Qubit,record = True):
	Td = [[1,0],[0,(1-1j)/math.sqrt(2)]]
	gate = Gate([q],Td,"Td")
	return gate.singleOperator(record)

#return a Qubits, which has two entanglement qubit
#the two qubit can be independent qubits, or one of them are a part of engtanlement 
#the first qubit is the control-qubit, the second qubit is the target-qubit
def CNOT(q1:Qubit,q2:Qubit,record = True):
	CNOT = [[1,0,0,0],[0,1,0,0],[0,0,0,1],[0,0,1,0]]
	gate = Gate([q1,q2],CNOT,"CNOT")
	return gate.CNOTOperator(record)


#execute the measurement, the types of the first argument must be Qubit; the second argument is optional,
#if the auQubit is "False", then the result of the measurement won't be appeared in the end result 
def M(q:Qubit,auQubit = False):
	I = [[1,0],[0,1]]
	gate = Gate([q],I,"M")
	return gate.MOperator(auQubit)

#Toffoli gate, three input and three output
def Toffoli(q1:Qubit,q2:Qubit,q3:Qubit):
	sg = SplitGate()
	executeRecord = sg.Toffoli()
	return sg.execute(executeRecord,[q1,q2],[q3],'Toffoli')
